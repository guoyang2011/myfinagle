/**
 * Generated by Scrooge
 *   version: 3.14.1
 *   rev: a996c1128a032845c508102d62e65fc0aa7a5f41
 *   built at: 20140501-114733
 */
package cn.changhong.core.thrift

import com.twitter.scrooge.{
  TFieldBlob, ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUtil}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait AccountService[+MM[_]] extends ThriftService {
  
  def create(user: User): MM[Boolean]
  
  def get(id: Long): MM[User]
  
  def list(): MM[Seq[User]]
  
  def map(): MM[Map[String, User]]
  
  def creates(users: Seq[User] = Seq[User]()): MM[Seq[Boolean]]
}


object AccountService {
  
  object create$args extends ThriftStructCodec3[create$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("create_args")
    val UserField = new TField("user", TType.STRUCT, 1)
    val UserFieldManifest = implicitly[Manifest[User]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        UserField,
        false,
        UserFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: create$args) {
    }
  
    override def encode(_item: create$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): create$args = {
      var user: User = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  user = readUserValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'user' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new create$args(
        user,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      user: User
    ): create$args =
      new create$args(
        user
      )
  
    def unapply(_item: create$args): Option[User] = Some(_item.user)
  
  
    private def readUserValue(_iprot: TProtocol): User = {
      User.decode(_iprot)
    }
  
    private def writeUserField(user_item: User, _oprot: TProtocol) {
      _oprot.writeFieldBegin(UserField)
      writeUserValue(user_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeUserValue(user_item: User, _oprot: TProtocol) {
      user_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class create$args(
      val user: User,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[User]
    with java.io.Serializable
  {
    import create$args._
      def this(
        user: User
      ) = this(
        user,
        Map.empty
      )
  
    def _1 = user
  
  
    override def write(_oprot: TProtocol) {
      create$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (user ne null) writeUserField(user, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      user: User = this.user,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): create$args =
      new create$args(
        user,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[create$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[create$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.user
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "create$args"
  }
  
  object create$result extends ThriftStructCodec3[create$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("create_result")
    val SuccessField = new TField("success", TType.BOOL, 0)
    val SuccessFieldManifest = implicitly[Manifest[Boolean]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: create$result) {
    }
  
    override def encode(_item: create$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): create$result = {
      var success: Option[Boolean] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.BOOL => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.BOOL
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new create$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Boolean] = None
    ): create$result =
      new create$result(
        success
      )
  
    def unapply(_item: create$result): Option[Option[Boolean]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): Boolean = {
      _iprot.readBool()
    }
  
    private def writeSuccessField(success_item: Boolean, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol) {
      _oprot.writeBool(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class create$result(
      val success: Option[Boolean],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Boolean]]
    with java.io.Serializable
  {
    import create$result._
      def this(
        success: Option[Boolean] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      create$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Boolean] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): create$result =
      new create$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[create$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[create$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "create$result"
  }
  
  object get$args extends ThriftStructCodec3[get$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("get_args")
    val IdField = new TField("id", TType.I64, 1)
    val IdFieldManifest = implicitly[Manifest[Long]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        IdField,
        false,
        IdFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: get$args) {
    }
  
    override def encode(_item: get$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): get$args = {
      var id: Long = 0L
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.I64 => {
                  id = readIdValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.I64
            
                  throw new TProtocolException(
                    "Received wrong type for field 'id' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new get$args(
        id,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      id: Long
    ): get$args =
      new get$args(
        id
      )
  
    def unapply(_item: get$args): Option[Long] = Some(_item.id)
  
  
    private def readIdValue(_iprot: TProtocol): Long = {
      _iprot.readI64()
    }
  
    private def writeIdField(id_item: Long, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IdField)
      writeIdValue(id_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIdValue(id_item: Long, _oprot: TProtocol) {
      _oprot.writeI64(id_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class get$args(
      val id: Long,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Long]
    with java.io.Serializable
  {
    import get$args._
      def this(
        id: Long
      ) = this(
        id,
        Map.empty
      )
  
    def _1 = id
  
  
    override def write(_oprot: TProtocol) {
      get$args.validate(this)
      _oprot.writeStructBegin(Struct)
      writeIdField(id, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      id: Long = this.id,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): get$args =
      new get$args(
        id,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[get$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[get$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.id
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "get$args"
  }
  
  object get$result extends ThriftStructCodec3[get$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("get_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[User]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: get$result) {
    }
  
    override def encode(_item: get$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): get$result = {
      var success: Option[User] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new get$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[User] = None
    ): get$result =
      new get$result(
        success
      )
  
    def unapply(_item: get$result): Option[Option[User]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): User = {
      User.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: User, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: User, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class get$result(
      val success: Option[User],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[User]]
    with java.io.Serializable
  {
    import get$result._
      def this(
        success: Option[User] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      get$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[User] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): get$result =
      new get$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[get$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[get$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "get$result"
  }
  
  object list$args extends ThriftStructCodec3[list$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("list_args")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: list$args) {
    }
  
    override def encode(_item: list$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): list$args = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new list$args(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): list$args =
      new list$args(
      )
  
    def unapply(_item: list$args): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class list$args(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import list$args._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      list$args.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): list$args =
      new list$args(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[list$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[list$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "list$args"
  }
  
  object list$result extends ThriftStructCodec3[list$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("list_result")
    val SuccessField = new TField("success", TType.LIST, 0)
    val SuccessFieldManifest = implicitly[Manifest[Seq[User]]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        Some(implicitly[Manifest[User]]),
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: list$result) {
    }
  
    override def encode(_item: list$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): list$result = {
      var success: Option[Seq[User]] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.LIST => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.LIST
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new list$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Seq[User]] = None
    ): list$result =
      new list$result(
        success
      )
  
    def unapply(_item: list$result): Option[Option[Seq[User]]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): Seq[User] = {
      val _list = _iprot.readListBegin()
      if (_list.size == 0) {
        _iprot.readListEnd()
        Nil
      } else {
        val _rv = new mutable$ArrayBuffer[User](_list.size)
        var _i = 0
        while (_i < _list.size) {
          _rv += {
              User.decode(_iprot)
  
          }
          _i += 1
        }
        _iprot.readListEnd()
        _rv
      }
    }
  
    private def writeSuccessField(success_item: Seq[User], _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Seq[User], _oprot: TProtocol) {
      _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
      success_item.foreach { success_item_element =>
        success_item_element.write(_oprot)
      }
      _oprot.writeListEnd()
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class list$result(
      val success: Option[Seq[User]],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Seq[User]]]
    with java.io.Serializable
  {
    import list$result._
      def this(
        success: Option[Seq[User]] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      list$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Seq[User]] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): list$result =
      new list$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[list$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[list$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "list$result"
  }
  
  object map$args extends ThriftStructCodec3[map$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("map_args")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: map$args) {
    }
  
    override def encode(_item: map$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): map$args = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new map$args(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): map$args =
      new map$args(
      )
  
    def unapply(_item: map$args): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class map$args(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import map$args._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      map$args.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): map$args =
      new map$args(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[map$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[map$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "map$args"
  }
  
  object map$result extends ThriftStructCodec3[map$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("map_result")
    val SuccessField = new TField("success", TType.MAP, 0)
    val SuccessFieldManifest = implicitly[Manifest[Map[String, User]]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        Some(implicitly[Manifest[String]]),
        Some(implicitly[Manifest[User]]),
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: map$result) {
    }
  
    override def encode(_item: map$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): map$result = {
      var success: Option[Map[String, User]] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.MAP => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.MAP
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new map$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Map[String, User]] = None
    ): map$result =
      new map$result(
        success
      )
  
    def unapply(_item: map$result): Option[Option[Map[String, User]]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): Map[String, User] = {
      val _map = _iprot.readMapBegin()
      if (_map.size == 0) {
        _iprot.readMapEnd()
        Map.empty[String, User]
      } else {
        val _rv = new mutable$HashMap[String, User]
        var _i = 0
        while (_i < _map.size) {
          val _key = {
              _iprot.readString()
  
          }
          val _value = {
              User.decode(_iprot)
  
          }
          _rv(_key) = _value
          _i += 1
        }
        _iprot.readMapEnd()
        _rv
      }
    }
  
    private def writeSuccessField(success_item: Map[String, User], _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Map[String, User], _oprot: TProtocol) {
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, success_item.size))
      success_item.foreach { _pair =>
        val success_item_key = _pair._1
        val success_item_value = _pair._2
        _oprot.writeString(success_item_key)
        success_item_value.write(_oprot)
      }
      _oprot.writeMapEnd()
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class map$result(
      val success: Option[Map[String, User]],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Map[String, User]]]
    with java.io.Serializable
  {
    import map$result._
      def this(
        success: Option[Map[String, User]] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      map$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Map[String, User]] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): map$result =
      new map$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[map$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[map$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "map$result"
  }
  
  object creates$args extends ThriftStructCodec3[creates$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("creates_args")
    val UsersField = new TField("users", TType.LIST, -1)
    val UsersFieldManifest = implicitly[Manifest[Seq[User]]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        UsersField,
        false,
        UsersFieldManifest,
        None,
        Some(implicitly[Manifest[User]]),
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: creates$args) {
    }
  
    override def encode(_item: creates$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): creates$args = {
      var users: Seq[User] = Seq[User]()
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case -1 =>
              _field.`type` match {
                case TType.LIST => {
                  users = readUsersValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.LIST
            
                  throw new TProtocolException(
                    "Received wrong type for field 'users' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new creates$args(
        users,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      users: Seq[User] = Seq[User]()
    ): creates$args =
      new creates$args(
        users
      )
  
    def unapply(_item: creates$args): Option[Seq[User]] = Some(_item.users)
  
  
    private def readUsersValue(_iprot: TProtocol): Seq[User] = {
      val _list = _iprot.readListBegin()
      if (_list.size == 0) {
        _iprot.readListEnd()
        Nil
      } else {
        val _rv = new mutable$ArrayBuffer[User](_list.size)
        var _i = 0
        while (_i < _list.size) {
          _rv += {
              User.decode(_iprot)
  
          }
          _i += 1
        }
        _iprot.readListEnd()
        _rv
      }
    }
  
    private def writeUsersField(users_item: Seq[User], _oprot: TProtocol) {
      _oprot.writeFieldBegin(UsersField)
      writeUsersValue(users_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeUsersValue(users_item: Seq[User], _oprot: TProtocol) {
      _oprot.writeListBegin(new TList(TType.STRUCT, users_item.size))
      users_item.foreach { users_item_element =>
        users_item_element.write(_oprot)
      }
      _oprot.writeListEnd()
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class creates$args(
      val users: Seq[User],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Seq[User]]
    with java.io.Serializable
  {
    import creates$args._
      def this(
        users: Seq[User] = Seq[User]()
      ) = this(
        users,
        Map.empty
      )
  
    def _1 = users
  
  
    override def write(_oprot: TProtocol) {
      creates$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (users ne null) writeUsersField(users, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      users: Seq[User] = this.users,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): creates$args =
      new creates$args(
        users,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[creates$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[creates$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.users
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "creates$args"
  }
  
  object creates$result extends ThriftStructCodec3[creates$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("creates_result")
    val SuccessField = new TField("success", TType.LIST, 0)
    val SuccessFieldManifest = implicitly[Manifest[Seq[Boolean]]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        Some(implicitly[Manifest[Boolean]]),
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: creates$result) {
    }
  
    override def encode(_item: creates$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): creates$result = {
      var success: Option[Seq[Boolean]] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.LIST => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.LIST
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new creates$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Seq[Boolean]] = None
    ): creates$result =
      new creates$result(
        success
      )
  
    def unapply(_item: creates$result): Option[Option[Seq[Boolean]]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): Seq[Boolean] = {
      val _list = _iprot.readListBegin()
      if (_list.size == 0) {
        _iprot.readListEnd()
        Nil
      } else {
        val _rv = new mutable$ArrayBuffer[Boolean](_list.size)
        var _i = 0
        while (_i < _list.size) {
          _rv += {
              _iprot.readBool()
  
          }
          _i += 1
        }
        _iprot.readListEnd()
        _rv
      }
    }
  
    private def writeSuccessField(success_item: Seq[Boolean], _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Seq[Boolean], _oprot: TProtocol) {
      _oprot.writeListBegin(new TList(TType.BOOL, success_item.size))
      success_item.foreach { success_item_element =>
        _oprot.writeBool(success_item_element)
      }
      _oprot.writeListEnd()
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class creates$result(
      val success: Option[Seq[Boolean]],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Seq[Boolean]]]
    with java.io.Serializable
  {
    import creates$result._
      def this(
        success: Option[Seq[Boolean]] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      creates$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Seq[Boolean]] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): creates$result =
      new creates$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[creates$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[creates$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "creates$result"
  }

  import com.twitter.util.Future

  trait FutureIface extends  AccountService[Future] {
    
    def create(user: User): Future[Boolean]
    
    def get(id: Long): Future[User]
    
    def list(): Future[Seq[User]]
    
    def map(): Future[Map[String, User]]
    
    def creates(users: Seq[User] = Seq[User]()): Future[Seq[Boolean]]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends AccountService$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends AccountService$FinagleService(
      iface,
      protocolFactory)
}