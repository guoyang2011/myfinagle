package cn.changhong.demoimport java.io._import java.net.InetSocketAddressimport java.nio.ByteBufferimport java.nio.channels._import java.nio.charset.Charsetimport java.util.concurrent.{Executors, Executor}import com.twitter.finagle.builder.ServerBuilderimport com.twitter.finagle.{Codec, CodecFactory, Service}import com.twitter.util.Futureimport org.jboss.netty.bootstrap.ServerBootstrapimport org.jboss.netty.buffer.ChannelBuffersimport org.jboss.netty.channel.Channelsimport org.jboss.netty.channel._import org.jboss.netty.channel.socket.nio.{NioServerBoss, NioWorker, AbstractNioSelector, NioServerSocketChannelFactory}import org.jboss.netty.handler.codec.http.{HttpMessageDecoder, HttpMethod, HttpVersion, DefaultHttpRequest}/** * Created by yangguo on 14-11-11. */trait Resource{  def imageLinks():Seq[String]  def links():Seq[String]}class HTMLPage(val i:Seq[String],val l:Seq[String]) extends Resource{  override def imageLinks(): Seq[String] = Seq()  override def links(): Seq[String] = Seq()}class Img() extends Resource{  override def imageLinks(): Seq[String] = Seq()  override def links(): Seq[String] = Seq()}object ByteBufferChannel extends App{  def main= {//    val header = ByteBuffer.allocateDirect(4)////    val body = ByteBuffer.allocateDirect(1024)//    val context = "hello Channel Buffer!"//    //  header.put(context.length.toString.getBytes(Charset.forName("utf8")))//    body.put(context.getBytes(Charset.forName("utf8")))//    header.putInt(body.limit())//    val buffers = Array(header, body)//    val fileOutChannel = new FileOutputStream("/Users/yangguo/channelbuffers.log").getChannel//    fileOutChannel.write(buffers)//    fileOutChannel.close()    val writeBuffer=ByteBuffer.wrap("Base Chunk File Test!".getBytes(Charset.forName("utf8")))    val file=new CHFileTemplate("/Users/yangguo/channelbuffers.log",1024*1024)  }}class CHFileTemplate(val filename:String,val fileLength:Long){  private[this] var position:Long=0  private[this] val file=new File(filename)//  require(file!=null&&file.exists()&&file.isFile)  private[this] val _stream:RandomAccessFile=new RandomAccessFile(file,"rw")  _stream.setLength(fileLength)  private[this] val _writeChannel:FileChannel=_stream.getChannel  private[this] val _readChannel:FileChannel=_stream.getChannel  def closeStream={    try{      _stream.close()      _writeChannel.close()      _readChannel.close()    }catch{case e=>}  }  def readChunk(buffer:ByteBuffer,position:Long):Int={    buffer.clear()    _readChannel.read(buffer,position)  }  def writeChunk(buffer:ByteBuffer,position:Long):Int={    buffer.flip()    _writeChannel.write(buffer,position)  }}object selector{  def registerChannel(selector:Selector,channel:SelectableChannel,ops:Int) {    if (channel != null) {      channel.configureBlocking(false)      channel.register(selector, ops)    }  }  def main= {    println("start server/..")    val serverChannel = ServerSocketChannel.open()    val serverSocket=serverChannel.socket()    val selector=Selector.open()    serverSocket.bind(new InetSocketAddress(10004))    serverChannel.configureBlocking(false)    serverChannel.register(selector,SelectionKey.OP_ACCEPT)    while(true){      val n=selector.select();      if(n >0 ){        val it=selector.selectedKeys().iterator()        while(it.hasNext){          val key=it.next()          key.readyOps()          if(key.isAcceptable){            val server=key.channel().asInstanceOf[ServerSocketChannel]            val channel=server.accept()            println(channel.getRemoteAddress+"acceptable....")            registerChannel(selector,channel,SelectionKey.OP_READ)            val buffer=ByteBuffer.wrap("hello world".getBytes(Charset.forName("UTF-8")))            channel.write(buffer)          }//          ByteBuffer.wrap("hello world".getBytes(Charset.forName("UTF-8"))))          if(key.isReadable){            val channel=key.channel().asInstanceOf[SocketChannel]            val buffer=ByteBuffer.allocate(1024)            Iterator continually(channel.read(buffer)) takeWhile(_ > 0) foreach{index=>              buffer.flip()              println("index="+index)//              println(new String(buffer.array(),Charset.forName("UTF-8")))              val str=new String(buffer.array(),Charset.forName("UTF-8"))              str.split("\r\n") foreach{line=>                println("line......")                line.split("\n") foreach{v=>                  v.split(":") match{                    case Array(key,value)=>println("key:"+key+",value:"+value)                    case Array(key)=>println(key+"\n\n\n")                    case e=>                  }                }              }              buffer.clear()            }          }          it.remove()        }      }    }  }}object netty{  println("netty server start...")  val hh=new SimpleChannelUpstreamHandler  val eventloop=new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool())  val bootstrap=new ServerBootstrap(eventloop)  bootstrap.setPipelineFactory(new ChannelPipelineFactory {    override def getPipeline: ChannelPipeline = {      val pipeline = Channels.pipeline      pipeline.addLast("test", new MyDecoder)      pipeline    }  })  bootstrap.bind(new InetSocketAddress(10001))}object NettyMyCodecService {  val server=new Service[String,String] {    override def apply(request: String): Future[String] = {      println(request+",")      Future.value("")    }  }  ServerBuilder()    .codec(MyCodec[String,String])    .name("test")    .bindTo(new InetSocketAddress(10000))    .build(server)  new Thread(new Runnable {    override def run(): Unit = selector.main  }).start()//  selector.main  Thread.sleep(1000)  val client=com.twitter.finagle.Http.newService("localhost:10004")  val request=new DefaultHttpRequest(HttpVersion.HTTP_1_1,HttpMethod.POST,"/")  request.setContent(ChannelBuffers.copiedBuffer("content".getBytes(Charset.forName("UTF-8"))))  println("client.....")  client(request) onSuccess { response =>    println("successed"+response)  }onFailure{e=>    println("failure=>"+e.getLocalizedMessage)  }}//class MyService[req,rep] extends Service[req,rep]{//  override def apply(request: req): Future[rep] = {//    Future.value()//  }////}class MyDecoder extends ChannelUpstreamHandler with ChannelDownstreamHandler{  override def handleUpstream(ctx: ChannelHandlerContext, e: ChannelEvent): Unit = {    e match{      case msg:MessageEvent=>        msg.getMessage        println("receive msg"+msg.getMessage.getClass.getName);        ctx.sendUpstream(msg)      case _=>ctx.sendUpstream(e)    }  }  override def handleDownstream(ctx: ChannelHandlerContext, e: ChannelEvent): Unit = ???}case class  MyCodec[req,rep] extends CodecFactory[req,rep]{  override def client: Client = {config=>    new Codec[req,rep]{      override def pipelineFactory: ChannelPipelineFactory = new ChannelPipelineFactory {        override def getPipeline: ChannelPipeline = {          val pipeline=Channels.pipeline          pipeline.addLast("test",new MyDecoder)          pipeline        }      }    }  }  override def server: Server = {config=>    new Codec[req,rep]{      override def pipelineFactory: ChannelPipelineFactory = new ChannelPipelineFactory {        override def getPipeline: ChannelPipeline = {          val pipeline=Channels.pipeline          pipeline.addLast("test",new MyDecoder)          pipeline        }      }    }  }}